# MLIR: Scaling Compiler Infrastructure for Domain Speciﬁc Computation

# MLIR：面向领域特定计算的编译器基础设施扩展

---

## 关键词

IR、方言、类型系统、并行、语义、图

---

## 核心思想

MLIR强调了简约性、可追溯性和渐进性原则，确保在编译过程中保留必要的高层语义和信息，便于优化和分析。MLIR通过支持方言、类型系统和并行编译来增强扩展性和可组合性，解决了当前编译系统中的透明度和性能问题。

---

## 主要工作

提出MLIR，为设计灵活且可扩展的编译器构建基础设施提供了具体的答案，该基础设施涵盖了从后端代码生成和异构系统编排，到机器学习的图级建模，以及编程语言和领域特定框架的高级语言语义。

---

## 学到的知识点

1. **许多问题在更高或更低级别的抽象层面上建模效果更好**：例如，在 LLVM IR 上对 C++ 代码进行源代码级分析非常困难。我们观察到许多语言（包括 Swift、Rust、Julia、Fortran 等）为了解决特定领域的问题而开发了自己的 IR，例如语言/库特定的优化、流敏感类型检查（例如线性类型），以及改进降低过程的实现。

2. MLIR：一种类似于 LLVM的编译器基础设施，但 LLVM 非常有利于标量优化和同构编译，而 MLIR 旨在将丰富的数据结构和算法（包括张量代数和算法、图表示以及异构编译）建模为一等值和操作。MLIR 允许混合和匹配优化，将编译过程分解为组件并重新定义降低和清理角色。这在很大程度上归功于模式重写基础设施，它将完整的转换捕获为小型局部模式的组合，并控制在单个操作的粒度上应用哪些模式重写。自动扩展、形式化和验证重写逻辑将是下一步的重要步骤。在后端方面，MLIR 的 DDR 与 LLVM 的指令选择基础设施类似，支持具有多结果模式和约束规范的可扩展操作。

3. **MLIR的总体原则**：
   
   - 简约性：Parsimony，将奥卡姆剃刀应用于内置语义、概念和编程接口。通过抽象操作和类型的属性，利用内在和偶然的复杂性。一次指定不变式，但在整个过程中验证正确性。在给定编译阶段的上下文中查询属性。内置功能很少，这为扩展性和定制化打开了大门。
   
   - 可追溯性：Traceability，保留信息，而不是恢复信息。声明规则和属性以启用转换，而不是逐步强制性规范。可扩展性伴随着通用的信息跟踪手段，并通过广泛的验证来强制执行。可组合的抽象源于“白盒化”它们的属性并分离它们的角色——类型、控制、数据流等。
   
   - 渐进性：Progressivity，过早降低是万恶之源。超越表示层，允许多个转换路径根据需要降低各个区域。结合抽象无关的原则和接口，这使得跨多个领域重用成为可能。
   
   **虽然这些原则已得到良好确立，但其中一个原则的实现往往会以牺牲另一个原则为代价**。例如，网络和操作系统堆栈的分层符合渐进性原则，但违反了简约性原则。在具有多层 IR 的编译器中，这种情况也屡见不鲜。此外，遵循这些原则可能会损害表达力和有效性；例如，安全关键和安全系统中的可追溯性涉及限制优化及其激进程度。

4. MLIR的灵感：**现代机器学习框架由许多不同的编译器、图技术和运行时系统组成——它们没有共享的通用基础设施或设计原则**。这在多个用户可见方面表现出来，包括错误消息不佳、边缘情况下的故障、性能不可预测以及将堆栈推广以支持新硬件的困难。

5. **保持更高层次的语义 [渐进性]**：系统需要保留分析或优化性能所需的 信息和结构。尝试在降低后恢复抽象语义是脆弱的，并且在低级别强制执行此信息通常是侵入性的（例如，在使用调试信息记录结构的情况下，需要重新访问所有阶段）。相反，系统应该保持计算的结构，并逐步降低到硬件抽象层。结构的丢失是有意识的，并且只发生在结构不再需要与底层执行模型匹配的地方。例如，系统应该在相关转换过程中保留结构化的控制流，例如循环结构；移除此结构，即降低到 CFG 本质上意味着不会执行任何进一步的转换来利用该结构。在生产编译器中对并行计算结构进行建模的最新技术突出了这项任务在一般情况下可能有多么困难。

6. **源位置跟踪[可追溯性]**：操作的来源——包括其原始位置和应用的转换——应该在系统内易于追踪。这旨在解决复杂编译系统中普遍存在的缺乏透明度问题，在这些系统中，几乎不可能理解最终表示是如何从原始表示构建的。

7. 属性：Attributes，MLIR 属性包含操作的编译时信息，除了操作码之外。属性是类型化的（例如，整数、字符串），每个 Op 实例都包含一个开放的键值字典，从字符串名称映射到属性值。在通用语法中，属性位于用大括号括起来的、逗号分隔的键值对列表中。属性的含义要么来自操作语义，要么来自它们所关联的方言。与操作码一样，属性集没有固定值。属性可以引用外部数据结构，这对于与现有系统集成很有用。

8. 位置信息：Location Information，MLIR 提供了一种紧凑的位置信息表示，并遵循可追溯性原则，鼓励在整个系统中处理和传播此信息。它可以用于保留生成操作的源程序堆栈跟踪，以生成调试信息。它标准化了编译器发出诊断信息的方式，并被广泛的测试工具使用。

9. 区域和块：Regions and Blocks，一个 Op 实例可能包含一个附加区域列表。区域在 MLIR 中提供嵌套机制：它包含一个块列表，每个块包含一个操作列表（可能包含更多区域）。与属性类似，区域的语义由其所附着的操作定义，但是区域内的块（如果有多个）构成一个控制流图（CFG）。Op 指定了跨区域的控制流。在本例中，循环体将重复执行，直到达到上限。

10. 值支配和可见性：Value Dominance and Visibility，操作只能使用在作用域内的值，即根据 SSA 支配、嵌套和封闭操作施加的语义限制可见的值。如果值遵循标准的 SSA 支配关系，则它们在 CFG 中可见，其中控制保证在到达使用之前通过定义。

11. 方言：Dialects，MLIR 使用方言来管理可扩展性，方言在唯一的命名空间下提供对操作、属性和类型的逻辑分组。方言本身不引入任何新的语义，而是作为一种逻辑分组机制，提供通用的操作功能（例如，方言中所有操作的常量折叠行为）。它们遵循简约原则，组织语言和领域特定语义的生态系统。方言命名空间以点分隔的前缀形式出现在操作码中。

12. 类型系统：Type System，MLIR 中的每个值都有一个类型，该类型在生成该值的 Op 中或在将该值定义为参数的块中指定。类型对值的编译时信息进行编码。MLIR 中的类型系统是用户可扩展的，并且可以例如引用现有的外部类型系统。MLIR 强制执行严格的类型相等性检查，并且不提供类型转换规则。操作符使用尾随函数式语法列出其输入和结果类型。

13. 混合方言：Mixing Dialects Together，MLIR 最深刻（但也最难理解）的方面之一是它允许并鼓励将来自不同方言的操作混合到同一个程序中。虽然某些情况很容易理解（例如，在同一个模块中保存主机和加速器计算），但最有趣的情况发生在方言直接混合时——因为这使得一整类我们以前在其他系统中从未见过的重用成为可能。

14. 并行编译：Parallel Compilation，MLIR 的一个重要方面是能够使用多核机器来提高编译速度。特别是，“从上层隔离”特性允许诸如函数之类的 Ops 选择使用 MLIR 的 Pass Manager 支持的并发 IR 遍历机制。事实上，这种特性保证了 SSA 使用-定义链不会跨越区域边界，并且可以独立处理。MLIR 也不包含整个模块的 使用-定义链，而是通过符号表引用全局对象，并将常量定义为带有属性的操作。

---

## 个人思考

本文是这18篇文章中唯一主要介绍IR设计思想、原则和方法的论文。给我带来的启示主要是，IR设计要设计良好的接口和较少的内置语义，好的接口与较少的内置语义保证软工设计实现的简便与较高的可扩展性与可定制性。IR要逐级慢慢地降低，因为IR的降低的本质是信息减少与损失的过程，越多的IR层提供了越多的优化机会。
