# TensorIR: An Abstraction for Automatic Tensorized Program Optimization

# TensorIR：自动张量化程序优化的抽象

---

## 核心思想

提出一种用于自动张量化程序优化的抽象——TensorIR，该抽象允许我们统一地表示张量内在函数和硬件约束。同时为给定算子自动生成优化的张量化程序（一个新的张量化感知自动调度器）。

---

## 主要工作

本文提出 TensorIR，一种用于自动张量化程序优化的抽象，并设计了一个名为“块”的关键抽象，它可以隔离张量化计算并提供有效的程序优化变换原语。作者构建了一个自动调度算法，该算法将张量化与其他优化共同执行，并生成高性能程序。

---

## 学到的知识点

1. 张量算子库：tensor operator libraries，这些硬件指令和微内核原语通常作用于多维张量区域，并有效地执行张量操作，例如多维加载、点积和矩阵乘法。我们将这些不透明的张量计算加速结构称为张量化内联函数，并将使用这些内联函数的转换过程称为张量化。为了充分利用这些硬件后端，现代机器学习系统需要优化包含层次循环嵌套、多维加载和张量内联的程序——我们称之为**张量化程序优化**。

2. TensorIR：一种用于自动张量程序优化的抽象。首先，作者引入了一种名为块的新结构，它允许我们将张量化计算区域从外部循环嵌套中分离出来。这种新的抽象允许我们有效地表示张量化计算，并将它们与循环嵌套、线程和内存层次结构结合起来。作者还引入了程序转换原语来表达丰富的潜在优化空间。作者在抽象和转换原语之上构建了一种新颖的自动调度算法。此外，TensorIR 抽象还允许我们表示和优化包含不规则计算和张量计算混合的程序，扩展了对正常张量表达式的支持范围。**将张量化计算与循环变换分离。同时，该抽象允许我们统一地表示张量内在函数和硬件约束。**

3. 分治法在张量化程序优化中的应用：领域专家自然会选择分治法——将原始程序分解为张量化计算的子问题和使用张量化计算的循环嵌套，然后分别优化它们。分治法允许开发人员专注于一个子问题，而无需担心其他子问题。此外，它还使我们能够针对多个张量化计算实现。

4. **块**：Block，TensorIR 中的一个块表示对多维缓冲区子区域的张量化计算。块的主体由一组块迭代器变量 𝑣𝑦, 𝑣𝑥, 𝑣𝑘 参数化，它表示一个抽象的张量化计算。用这些块迭代器变量的不同值组合实例化后，块映射到不同的具体运行块实例。这些迭代器变量可以绑定到包含外部循环迭代器的表达式，这意味着块实例的执行顺序。块的主要设计原理是隔离张量化计算——我们希望能够在不查看块体的情况下变换块外的循环嵌套。然而，与标量计算不同，我们可能无法从不透明的张量计算体中提取变换所需的依赖信息。因此，作者引入了一种包含足够依赖信息以进行变换的块签名。此外，该签名可用于独立验证变换期间迭代器绑定的正确性。
   
   - 块迭代器域：Block Iterator Domain，虽然可以通过将块迭代器绑定到任何循环嵌套来实例化块的主体计算，但大多数实例化并不对应于相同的计算。为了确保变换中计算的一致性，我们在块签名中存储迭代器域信息和迭代器的约束。
   
   - 访问区域和依赖关系：Access Region and Dependency，为了提供足够的依赖信息，块签名包含块相对于多维缓冲区的访问区域和读/写依赖关系。依赖信息在转换过程中使用。我们只标记每个块相对于多维缓冲区的依赖关系，而不是其他语句（块）。这种间接寻址方式能够实现更广泛的转换，例如数据布局转换和重新计算，这些转换对于张量化程序优化至关重要。
   
   - 约简块和初始化：Reduction Block and Initialization，约简计算通常包含一个初始化步骤和一个更新步骤。我们可以自然地将约简计算映射到两个块中。但另一方面，通常有助于共同做出两个步骤的调度决策（例如平铺和计算位置）。我们为执行归约的块引入了可选的初始化语句。初始化语句在归约的第一次迭代期间执行。这种归约块表示在转换过程中特别有用。我们提供转换原语来在基于两个块的表示和基于初始化块的表示之间进行转换，以便我们能够为低级代码生成选择最佳表示。

5. 调度：对于给定的输入程序，我们需要生成一个具有等效语义的丰富程序搜索空间。我们引入了一些原语，可以将 TensorIR 程序转换为等效的优化程序。遵循现有的张量程序优化惯例，我们将此过程称为调度。

6. 可调度的块：如果一个块仅包含以子块为叶节点的循环嵌套，则该块是可调度的。过分析子块签名及其依赖关系信息，我们可以转换可调度块内的循环嵌套和子块计算位置。值得注意的是，可调度块可以包含不可调度子块（例如，不透明的 Tensor Core 计算）。一个不透明块也可以包含一个可调度子块。基于块隔离，我们仍然可以有效地独立探索可调度部分的搜索空间，同时保持相同的不透明块。我们在本小节的剩余部分描述调度原语。

7. 张量化候选生成：Tensorization Candidate Generation，给定一对后端目标和一个输入程序，我们首先将程序主体与可能的 TensorIntrin 匹配，以生成张量化候选。匹配以逐步的方式进行。我们首先匹配表达式模式 C [.] += A[.] × B[.]，而不考虑索引。然后，我们通过提出索引之间可能的映射来细化匹配结果。

8. 数据移动：Data Movement，现有的张量程序自动调度器将设计重点放在计算调度上，并将不同内存范围之间的数据移动视为次要优先级。然而，由于张量内在函数极大地提高了计算吞吐量，数据移动成为张量程序的瓶颈。此外，数据移动决策通常取决于计算调度决策，例如平铺、线程绑定、执行范围和生产者-消费者数据流粒度。**故在本调度器中，数据移动是优先考虑的**。具体来说，我们在草图生成规则决定执行数据移动的地方插入 AutoCopy 块。该复制块隐藏了内存调度细节，仅在块签名级别公开必要的缓冲区访问信息。隔离的复制块允许草图生成独立地进行计算调度决策，而无需考虑如何进行数据移动。AutoCopy 块的主体描述了数据移动任务的详细信息，包括缓冲区位置映射、线程和存储范围要求。数据移动调度器将此信息作为输入，并执行与内存相关的调度转换，例如插入中间缓存阶段、利用数据移动张量内联函数、矢量化、协作获取或步长填充以避免银行冲突。

9. 进化搜索：Evolutionary Search，在张量化程序草图生成阶段之后，我们可以得到数十亿个可能的诱导程序。我们使用进化搜索来探索空间并找到一个优化的张量化程序。我们的搜索从给定程序草图的选择的随机初始化开始。然后，我们对当前的程序集进行变异。然后，我们从变异后的候选程序中选择有希望的程序，并在我们感兴趣的硬件后端上对其进行基准测试。我们从评估阶段收集数据以更新学习到的成本模型。

10. 张量化计算的成本模型：Cost Model for Tensorized Computation，构建了一个基于特征提取的程序的提升树集成成本模型。特征向量包含与内存访问模式、重用和循环注释相关的信息。重要的是，作者从孤立的块签名以及块主体（例如，标记 Tensor Core 的使用）中提取特征。作者的成本模型可以看作是对先前张量化程序方法的推广。作者认为，针对张量化程序的有效成本模型是未来研究的一个有前景的领域。

---

## 个人思考




